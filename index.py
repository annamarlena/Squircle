# Programming Project: "Squircle"
# Programmer: Anna Marlena
# March 1, 2015
 
# This program:
# estimates the value of pi using the Madhava-Leibniz series
# and uses the Zelle graphics module to animate the statistical
# approach of determining pi.

# import the math module
import math

# import Zelle's graphics module
from graphics import *

# import the random module
import random

# part 1A
# define a function that approximates the value of pi for k in range [0,5]
# I chose to use slightly longer code for this to demonstrate how to step through
# this equation (mainly for my own future reference.) The part 2 function completes
# a similar calculation with fewer lines.
def madhava():
    lst = []    # create an empty list
    k = 0       # set k to zero
    calc = 0
    while k < 6:
        denom = 2 * k + 1   # set a variable and do the calc for the denominator
        negk = k * -1       # set a variable to give k a negative value
        numer = (-3) ** negk   # set a variable and do the calc for the numerator
        num = numer / denom # set a variable that holds the ratio
        lst.append(num)     # append the result to the list
        k += 1           # increment k by one and run through the calcs again
    print('\n---PART 1A---')
    print('\nList generated by this calculation: ',lst)     
    total = sum(lst)        # add up all the numbers in the list
    print('\nList sum: ',total) # print the total sum of the listed numbers
    leibniz = (float(math.sqrt(12) * total)) # multiply the total by the square rt of 12
    print('\nThe Madhava-Liebniz approximate value of pi for range [0,5] is: ',leibniz)
    calc = (float(math.pi - leibniz)) # calculate difference between apprxs of pi
    print('\nThe difference between the value of pi in the math module and')
    print('that calculated by the series computation for range [0,5] is: ',calc)
        
# part 1B
# use the value of pi from the math module to determine at what value of k
# there is less than a 0.0001 difference between the series and pi from the
# math module. Output this value to the terminal and show the value of k
# reached, and the difference of pi from the math module vs the series
# estimation
def difference():
    lst = []    # create an empty list and set k to zero as above
    k = 0
    leibniz = (float(math.sqrt(12) * (sum(lst)))) # set a var that gives an apprx of pi
    while (leibniz - math.pi) > 0.0001 or (leibniz - math.pi) < 0: # set parameters
        num = ((-3) ** (-k) / ((2 * k) + 1)) # set var to calc the ration
        lst.append(num)  # append the value held in var num to lst
        leibniz = (float(math.sqrt(12)) * (sum(lst))) # set var that gives apprx of pi
        k += 1 # increment k by 1 to run through calcs until the parameters are met and
        # a value of k is found at which there is less than a 0.0001 difference.
    difference = leibniz - math.pi # subtract to find the difference between approximations
    print('\n---PART 1B---')
    print('\nPi calculated : ',leibniz,' (Madhava-Leibniz series)')
    print('Pi in math module: ',math.pi,' (the Python math module)')
    print('\nThe difference of the Madhave-Leibniz series approximation')
    print('minus the Python math module approximation is:',"%8f" % difference)
    print('\nThe value of k at which there is less than a 0.0001')
    print('difference between the approximations is: ',k)

        
# part 2
# estimate the value of pi using points which fill a circle within a square
# using Zelle's graphics module

# define a variable that creates points to fill the circle and square
# this function will be called in a later function in order to draw varying
# amounts of points instead of only one set number of points
def fill(N,win):    
    ptsInCircle = 0 # start with an empty circle 
    i = 0           # iteration counter
    x = []          # empty list of x integers
    y = []          # empty list of y integers
    while i < N:       
        randx = random.randint(0,200) # get random integer for x
        randy = random.randint(0,200) # get random integer for y
        x.append(randx)     # append to x list
        y.append(randy)     # append to y list
        d = math.sqrt(float(((x[i] - 100.0) ** 2) + ((y[i] - 100.0) ** 2))) # set var d
        if d <= 100.0:      # set the control for red points within the circle
            p = Point(x[i],y[i]) # graph the point using the lists x and y
            c = Circle(p,3)     
            c.setFill('red')
            c.draw(win)         # draw the red point
            ptsInCircle += 1    # increment the count of points inside the circle by 1
            i += 1          # add 1 to i and go back to the top of the while loop
        else:               # anything outside the circle's radius
            p = Point(x[i],y[i]) # graph the point using the x and y lists
            c = Circle(p,3)
            c.setFill('black')
            c.draw(win)         # draw the black point
            i += 1              # add 1 to i and return to the while loop

    # calculate and output the estimate for pi 
    piEstimate = (ptsInCircle / N) * 4.0 # the formula to estimate pi from generated points
    print('The total number of points graphed is: ',N)
    print('The total number of points within the circle is: ',ptsInCircle)
    print('This visual graphic estimates the value of pi at: ',piEstimate)
    print('\nPlease click anywhere on the graph to continue.')      
        
    return  win.getMouse(), win.close()

# define a function that opens a window and draws a red circle within a black square
def window():
    win = GraphWin("Squircle",500,500,autoflush=True) # window size, fill all points at once

    # create a set of boundaries on x,y
    win.setCoords(-100,-100,300,300)
    xp1 = Point(0,0)
    xp2 = Point(300,0)
    xaxis = Line(xp1,xp2)
    xaxis.setArrow('last')
    yp1 = Point(0,0)
    yp2 = Point(0,300)
    yaxis = Line(yp1,yp2)
    yaxis.setArrow('last')

    # create a circle centered at 1.0, 1.0 with a radius of 1
    c = Circle(Point(100.0,100.0),100)
    c.setWidth(2)
    c.setOutline('red')

    # create two points in order to create a square
    p1 = Point(0,0) # lower left corner
    p2 = Point(200,200) # upper right corner
    r = Rectangle(p1,p2) # set the remaining instructions
    xaxis.draw(win) 
    yaxis.draw(win)
    # draw the red circle within the black square
    c.draw(win)
    r.draw(win)
    return win

# create the main function, which graphs points in amounts of 10, 100, and
# 1000 and outputs an estimation of pi for each 
def squircle():
    print('\n---PART 2---')
    # set the number of iterations and number of points to graph for each iteration
    N = 10
    run = 1
    for i in range(0,3): # repeat the following 3 times:
        print('\nESTIMATION ',run,':')
        win = window() # call the function that opens the graph
        fill(N,win)     # call the function that plots points on the graph
        run = run + 1   # set the run count
        N = N * 10      # multiply the number of points to graph by ten

# program greeting
print('---Squircle!---')
print('\nWelcome to the exciting rollercoaster otherwise known as')
print('Python Programming Project 1. Seat belts are not required')
print('(but should have been recommended). Professor and institution')
print('of higher education not liable for injury to student.')
print('Side effects may include insomnia, moments of anxiety-induced')
print('nausia,and a scavenger hunt through textbook and past labs.')
print('Buckle your seatbelt, this graphic Squircle is FUN!')
print('\nThis program:')
print('\nEstimates the value of pi using the Madhava-Leibniz series')
print('and uses the Zelle graphics module to animate the statistical')
print('approach of determining pi.')

madhava()

difference()
    
squircle()

print('\n---Thank you for choosing Squircle for your pi estimation needs!---')
